CS660 PA3 Write-up
Jiahe Zhang

Class Design:
In this section, we are introduced with the operation method such as join, insert, delete and filter,
then, we implemented the group operation by complete the skeleton of Aggregates classes.

> Filter: This operator only returns tuples that satisfy a Predicate that is specified as part of its
    constructor. Hence, it filters out any tuples that do not match the predicate.

> Join: I implemented that operator joins tuples from its two children according to a JoinPredicate
    that is passed in as part of its constructor. I used a double nested loop to iterate through
    the left child and the right child to join into a big table.

> Predicate and IndexPredicate: The design of these two classes are simple. They are implemented
    in order to compare a given value to the one exists. The core in these classes is the compar-
    sion method.

> Aggregates & Aggregators: For Aggregates class, I think the most important design in the aggregate class
    is to take track of two iterators, one for iterating through the input tuples, and the other is
    used to iterate through the new aggregation. For example, in open() method of aggregates class,
    we loop through all records in the input table and join them together for the aggregation,so open()
    uses the dbiterator child to serve for the aggregation iterator. Similarly, rewind() and fetchNext()
    all serves for the aggregation iterator. Yet, the getTupleDesc() is used to get the current td,
    which is served for the dbiterator, child.
    In integer and string aggregators, I used hash map to take track of each group. But implementations for
    StringAggregate and IntegerAggregate are slightly different. In the MergeTupleIntoGroups() method in
    StringAggregate, I increment the counter in the hashmap for key that are found in the hashmap,
    else add a new key value pair to the hashmap. In IntegerAggregate, we need to consider operations
    (COUNT, SUM, AVG, MIN, MAX) into account. Thus, I feel like adding a helper class which represents
    a map of groupVal is more convinent.


> HeapPage & HeapFile: Continuing the past work. The difficulty is in the insertTuple method. In that
    method, we first use transactionId to get a heap page, if we could find a heappage that is not
    full, we insert the tuple into that heap page, else, we create a new heappage using RandomAccessFile.


> Insert & Delete:
    I encountered a bug for these two method, and finally realized that I have to set a flag so that
    the fetchNext() method will not return value over time. Everything else works as expected when
    implementing it similar to the other classes.


I spent a few days working on the project. The instructions are clear, and word load is evenly distributed.
The difficulties are mainly appearing in the IntegerAggregator class and HashEquiJoin class. I spent majority
of my time completing and debugging for these two classes.
In the HashEquiJoin.java file, I encountered some problem as it didn't pass the tests initially. I searched
online and found that I have to have an extra method called loadMap() in order to have fetchNext() success-
fully running. However, I still feel vague about how this method would work.